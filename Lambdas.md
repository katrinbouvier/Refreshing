3/08/2020
>## Definition
>Лямбда-выражение, по сути, анонимный метод (не имеющий имени). Однако, сам по себе он не выполняется, вместо этого, он используется, чтобы реализовать метод, определеный функциональным интерфейсом. Следовательно, форма лямбда-выражения -- это анонимный класс. 
>Функциональный интерфейс содержит один и только один абстрактный метод, то есть интерфейс выражает одно действие. Лямбды могут использоваться только в том контексте, в котором ясно определен конечный тип (target type) выражения. SAM -- Single Abstract Method.
>Если в интерфейсе определены методы класса `Object`, он все равно остается функциональным. 
>## Syntax
>`->` левая часть указывает параметры, требуемые выражением, правая указывает на тело лямбды (действия). 
>Есть 2 типа тела лямбды: единственное выражение и блок кода. 
>В круглых скобках указываются аргументы. Если агрумент один, то скобки можно опустить. Но если аргументов нет, то необходимо оставить скобки пустыми. 
>Если явно определяется тип одного параметра, то нужно явно определить и тип второго.
>Лямбда не может определять типы параметров самостоятельно. Следовательно, лямбда не может быть дженериком. Однако, можно создать дженерик функциональный интерфейс.

`() -> 123.45` is similar to `double myMeth() { return 123.45; }`
`() -> Math.random()*100` получает псевдо-рандомное значение, умножает на 100 и возвращает результат
`(n) -> (n%2) == 0` вернет `true`, если `n` - четное	// можно `n -> ...`
>## Functional Interfaces
`interface MyNumber { double getValue(); }`
>Лямбды не выполняются сами по себе, скорее, они формируют реализацию абстрактного метода, определенного функциональным интерфейсом, который указывает на возвращаемый тип. 

`MyNumber myNum;`
`myNum = () -> 123.45;`
>Лямбды дают возможность трансформировать сегмент кода в объект.

// Вызываем `getValue()`, который реализован заранее присвоенным лямбда-выражением
`System.out.println(myNum.getValue());`
> Функциональные интерфейсы следует помечать аннотацией @FunctionalInterface (purely informational). Компилятор в этом случае проверяет, что аннотируемый элемент является интерфейсом с единственным абстрактным методом. Также, страница документирующих комментариев включает в себя пояснение, что объявляемый интерфейс является функциональным.
> Лямбда должна быть сопоставима с абстрактным методом, который она реализует.
> Лямбда может выбросить проверяемое исключение, только если оно перечислено в абстрактном методе функционального интерфейса.
>## Method References
>Ссылка на метод позволяет ссылаться на метод без его выполнения. 
>Чтобы сослаться на статический метод используют `ClassName::methodName`:

`out = StringOp(MyStringsOps::strReverse, in);`
> Для вызова метода экземпляра(instance method) сначала нужно создать экземпляр класса, а затем использовать `::`.

`MyStringOps strOps = new MyStringOps();`
`out = StringOp(strOps::strReverse, in);`
>## Generic Functional Interface

    interface SomeFunc<T> {
    	T func(T t);
    }
>T определяет и тип параметра, и тип возвращаемого значения, поэтому интерфейс сопоставим с лямбда-выражением.


<!--stackedit_data:
eyJoaXN0b3J5IjpbLTgwODI3ODc3MCwtODU3NDk5MzEyLC0yMD
MzMzYwMzMsLTM4NjAwNjAwNF19
-->