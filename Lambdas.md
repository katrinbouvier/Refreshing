3/08/2020
>## Definition
>Лямбда-выражение, по сути, анонимный метод (не имеющий имени). Однако, сам по себе он не выполняется, вместо этого, он используется, чтобы реализовать метод, определеный функциональным интерфейсом. Следовательно, форма лямбда-выражения -- это анонимный класс. 
>Функциональный интерфейс содержит один и только один абстрактный метод, то есть интерфейс выражает одно действие. Лямбды могут использоваться только в том контексте, в котором ясно определен конечный тип (target type) выражения. SAM -- Single Abstract Method.
>Если в интерфейсе определены методы класса `Object`, он все равно остается функциональным. 
>## Syntax
>`->` левая часть указывает параметры, требуемые выражением, правая указывает на тело лямбды (действия). 
>Есть 2 типа тела лямбды: единственное выражение и блок кода. 

`() -> 123.45` is similar to `double myMeth() { return 123.45; }`
`() -> Math.random()*100` получает псевдо-рандомное значение, умножает на 100 и возвращает результат
`(n) -> (n%2) == 0` вернет `true`, если `n` - четное	// можно `n -> ...`
>## Functional Interfaces
`interface MyNumber { double getValue(); }`
>Лямбды не выполняются сами по себе, скорее, они формируют реализацию абстрактного метода, определенного функциональным интерфейсом, который указывает на возвращаемый тип. 

`MyNumber myNum;`
`myNum = () -> 123.45;`
>Лямбды дают возможность трансформировать сегмент кода в объект.

// Вызываем `getValue()`, который реализован заранее присвоенным лямбда-выражением
`System.out.println(myNum.getValue());`
> Функциональные интерфейсы следует помечать аннотацией @FunctionalInterface (purely informational). Компилятор в этом случае проверяет, что аннотируемый элемент является интерфейсом с единственным абстрактным методом. Также, страница документирующих комментариев включает в себя пояснение, что объявляемый интерфейс является функциональным.
> 
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE2NDg3MjkyMTgsLTM4NjAwNjAwNF19
-->